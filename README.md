
# DazzleConf [![Maven Central](https://img.shields.io/maven-central/v/space.arim.dazzleconf/dazzleconf-parent?color=brightgreen&label=maven%20central)](https://mvnrepository.com/artifact/space.arim.dazzleconf/dazzleconf-core) [![Javadoc](https://javadoc.io/badge2/space.arim.dazzleconf/dazzleconf-core/javadoc.svg)](https://javadoc.io/doc/space.arim.dazzleconf/dazzleconf-core) [![discord](https://img.shields.io/discord/784154359067443280?label=discord)](https://discord.gg/es9EuHqqNr)

A sleek, usable, and fully-featured configuration library. Supports HOCON, TOML, and YAML.

### Objectives

* Extensible and user-friendly. All types use the same framework, and library users can easily add new types.
* Type safety. Configuration is an immutable interface.
* Automatically update old configurations with the latest keys. No need to version config files.
* No NULLs. No public mutable fields. No stringly-typed spaghetti such as `getString("key")`, and no type-unsafe calls like `getInt("maybe-not-really-an-integer")`.
* Informative, helpful error reports. Messages that human beings (even non-programmers!) can understand. Reports key path and line number, and library error messages can even be translated depending on the locale. 

### Features

DazzleConf is a clean, well-tested library to meet your configuration needs. It lets you use an interface, define default values and return types in a type-safe fashion.
The API has both high-level convenience and low-level strength, which makes it quick to get running:

```java
Configuration<DatabaseConfig> configuration = Configuration.defaultBuilder(DatabaseConfig.class).build();
Backend backend = new YamlBackend(new PathRoot(Path.of("config.yml")));
DatabaseConfig config = configuration.configureOrFallback(backend, new StandardErrorPrint(output -> output.printTo(System.out)));
// DONE! You now have a user-friendly, type-safe configuration system
```

This library is covered by rigorous testing, and it should have no bugs. Starting with version 2.0, anyone who finds **two bugs** in the core library will be featured in this README.md.

### Usage Example

Here's a more complete example.

```java
public interface DatabaseConfig {
  
  @Comments("Retry count for contacting the database")
  default int numberOfTries() { return 3; }
  
  @IntegerRange(min = 1, max = Integer.MAX_VALUE - 1)
  default long boundedNumeric() { return 10; }
  
  default MyEnum enumValue() {
      return MyEnum.ONE;
  }

  enum MyEnum {
      ONE, 
      TWO
  }

  @SubSection Display display();

  interface Display {

      @Comments("The message shown when a certain thing happens")
      default String userMessage() {
          return "Hello user";
      }

      default boolean enableUserMessage() { return true; }

      @Comments("Every annotation shown above works here too")
      default String flexibility() {
          return "Also, methods are inherited if this interface extends another, enabling inheritable config interfaces";
      }

  }
  
  @Comments("Custom objects are supported - and can make use of existing annotations")
  @DefaultString("https://github.com") // Because who wants to construct URL directly?
  URL validUrl();

}
```

Let's use the YAML backend and write the default values.

```java
Configuration<DatabaseConfig> configuration = Configuration.defaultBuilder(DatabaseConfig.class).build();
// Using configureWith() will automatically write the default configuration if it doesn't exist
LoadResult<DatabaseConfig> loadResult = configuration.configureWith();
DatabaseConfig databaseConfig = loadResult.getOrThrow(); // Can substitute better error handling
```

When using the YAML backend, the following result is generated by writing the default configuration.

Notice how keys are mapped to `lower-snake-case`. This happens automatically depending on the backend.

```yaml
some-integer: 3
bounded-numeric: 10
enum-value: 'ONE'
display:
  # The message shown when a certain thing happens
  user-message: 'Hello user'
  enable-user-message: true
  # Every annotation shown above works here too
  flexibility: 'Also, methods are inherited if this interface extends another, enabling inheritable config interfaces'
valid-url: 'https://github.com'
```

The same document can be reparsed to an instance of the configuration interface. Type and constraint validation is performed when config values are parsed and loaded, not when they are retrieved - having an instance of the config interface is enough to ensure the configuration is valid.

### Configuration formats

We offer multiple configuration formats depending on your preference. Simply depend on the artifact matching the format you want.

| Format | Reference                                                            | Artifact           | Comment Support |
|--------|----------------------------------------------------------------------|--------------------|-----------------|
| HOCON  | [HOCON.md](https://github.com/lightbend/config/blob/master/HOCON.md) | `dazzleconf-hocon` | Writing only    |
| TOML   | [TOML 1.0 spec](https://toml.io/en/v1.0.0)                           | `dazzleconf-toml`  | Full            |
| YAML   | [YAML 1.2 spec](https://yaml.org/spec/1.2.2/)                        | `dazzleconf-yaml`  | Full            |

### Full Feature List

* Serializers can depend on each other.
* Full generics support. Support for infinitely nested generics, collections, configuration subsections, etc.
  * `List<List<List<List<MyType>>>>` is fully usable, requiring no extra code.
  * Library users can write their own type like `MyGeneric<T>`, extract the generic parameter T, and get a serializer for T.
  * Anything you can imagine is possible. Even generic parameters on the configuration itself are supported. For example, `MyConfig<V>` with a method `V myOption()`.
  * Annotations are usable as well.
* Immutable and thread safe by design.
  * Values loaded once and never modified thereafter.
  * Loading is fail-fast: if a configured value from the text file is not interpretable as the desired return type, it is rejected.
* Reading and writing:
  * Read from file. ✔️
  * Write to file. ✔️
  * Combined read/write operation, to update existing data. ✔️
  * Can write any object implementing the configuration interface (not just implementations by the library).
* Reloading:
  * Easy-to-reload "shell" instance can be created, to swap the values in a live configuration.
* Migrations:
  * Detect old versions, and migrate safely to latest version.
  * Lets you change keys, move keys around, and merge or separate sections.
  * Lets you migrate from other configuration libraries when their files exist on disk.
* Notifications. Caller can listen for:
  * When data is updated. E.g. `"3" -> 3`.
  * When missing keys are added.
  * If using migrations, when migrations are triggered.
* Excellent and translatable error messages:
  * Select user locale, or auto-detect default locale.
  * Community can provide translations of all messages.
  * If you made a mistake as a developer, error message includes information needed to fix the problem.
* Backends:
  * HOCON, TOML, and YAML implemented so far.
  * No external dependencies: they are shaded in.
  * Relevant library features (key format, comment support) automatically adapt to the backend in use.
* Low-level `DataTree` API: 
  * Can read and write data, independent of the backend.
  * Can read and write comments if the backend supports it, including document-level header and footer.
  * Comments can be placed above, below, or inline.

## Extra

### Requirements

* Java 8

Java 11 is recommended, but not required.

`module-info` files are also included, and these are backwards compatible with Java 8.

### Getting Started

This page will help you out: https://github.com/A248/DazzleConf/wiki/Getting-Started

The wiki also has extra examples such as with setting up a reloadable configuration, automatically updating the configuration with the latest keys, and more.

### Documentation

See [the docs folder](https://github.com/A248/DazzleConf/tree/master/docs) of this repository for a detailed overview.

Additionally, the javadocs are published with the artifact. They can also be browsed [here](https://javadoc.io/doc/space.arim.dazzleconf/dazzleconf-core).

### License

LGPL. See the license file for more information.
